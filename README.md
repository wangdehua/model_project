# model 设计模式实现的工程
#包 strategy 是 策略 模式的实现
策略模式出现的场景,多个判断 if ... else if ... else if ...
本案例是下单采取策略模式 :
    有些App根据支付方式的不同, 下单的逻辑也不一样 , 如果不用设计模式可能会存在大量的if..else..
    要做到符合 java 的开闭原则(对外开放,对内闭合,最简单的理解,对外部添加部分功能,内部不改动代码)
    我这里是根据订单类型 : 支付宝/微信/银联类 , 账户/钱包类 , 信用卡打折类 来做的 .... 
    主要区分字段是 orderType
    
整体思路:
    1.自定义注解，在具体的每个策略类上使用自定义注解指定好类型
    2.实现接口ApplicationContextAware，项目启动后，该类利用applicationContext获取容器中所有有
        自定义注解的类
    3.读取获取的所有类的自定义注解的值，注解值作为key，类作为value放在map中
    4.客户端用时，根据传入的orderType值，相当于自定义注解的值，然后拿到类，
    然后从applicationContest.getBean(类)，然后调用对象方法即可了
  这样把所有的if else判断都消除了，代码看着非常简洁
  
#包 template 是 模板 模式的实现
模板模式出现的场景 , 多个方法做的是同一个业务,只不过具体的实现细节不一样 , 
比如 : 支付宝支付回调,微信支付回调,银联支付回调等等
本案例是 根据 支付回调 做的 :

整体思路 :
    1.自定义注解,在每个具体的实现类上定义好对应的实现类型
    2.实现接口ApplicationContextAware，项目启动后，
        该类利用applicationContext获取容器中所有有自定义注解的类
    3.读取获取的所有类的自定义注解的值，注解值作为key，类作为value放在map中
    4.客户端调用url 为 localhost:8080/payResultNotify/1 , 
        后面的 1/2/3 即为每个不同的模板类的定义的注解编号
    
   这样把所有的 支付通知都放到一个入口里 , 根据传入的templateId走具体的实现 , 
   实现了对外开放,对内扩展的优点

#包 factory为工厂模式的实现
simple里为简单工厂的实现 , 多个开卡方式进来会创建不同的开卡业务对象 : 
App开卡 , 钱包开卡 , 第三方京东开卡等等

整体思路 :
    1 . 将几种业务方式的对象交给 spring 管理
    2 . 在工厂中根据类型获取到具体的Class
    3 . 从spring上下文中获取到 bean ,即为工厂生产的bean
    
